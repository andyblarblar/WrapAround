@using System.IO
@using System.Numerics
@using System.Runtime.Serialization.Formatters.Binary
@using System.Text.Json.Serialization
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.FileReader
@using WrapAround.Logic

@inject IJSRuntime JsRuntime
@inject IFileReaderService fileReaderService

<style>
    #render-window canvas {
        background-color: #EEEEEE;
    }
</style>

<div id="game-modal">
    <div id="render-window" @onmousedown="@(MouseDown)" @onmousemove="@(MouseMove)" @onclick="@(MouseClick)" @onmouseup="@(MouseUp)" @onmouseout="@(MouseUp)" @onmousedown:preventDefault @onmousemove:preventDefault @onclick:preventDefault @onmouseup:preventDefault @onmouseout:preventDefault>
        <BECanvas Width="1250" Height="700" @ref="_canvasReference"></BECanvas>
    </div>

    @if (debug)
    {
        <button @onclick="@Redraw">redraw</button>
        <br />
        <p style="color: red">number of blocks: @_blocks.Count</p>
        <br />
        <p style="color: red">IsDragging @_isDragging</p>
    }

    <button @onclick="@DownloadMap">download map</button>
    <br />
    <input style="color: #eeeeee" type="file" @ref=inputTypeFileElement /><button @onclick=ReadFile>Read file</button>


</div>



@code
{
    [Parameter]
    public bool debug { get; set; }


    //###########ACTUAL CODE###############

    private Canvas2DContext _context;

    private List<Hitbox> _blocks = new List<Hitbox>();

    protected BECanvasComponent _canvasReference;

    private bool _isDragging;

    private int _draggingIndex;

    private GameMap _map;

    private ElementReference inputTypeFileElement;

    #region canvas

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _context = await _canvasReference.CreateCanvas2DAsync();
        await _context.SetFillStyleAsync("red");
    }

    private async Task<float> GetRealMouseX(MouseEventArgs e)
    {
        var canvasX = await JsRuntime.InvokeAsync<float>("GetRealCanvasX", "render-window");
        return (float) (e.ClientX - canvasX);
    }
    
    private async Task<float> GetRealMouseY(MouseEventArgs e)
    {
        var canvasY = await JsRuntime.InvokeAsync<float>("GetRealCanvasY", "render-window");
        return (float) (e.ClientY - canvasY);
    }

    private async Task MouseDown(MouseEventArgs e)
    {
        for (var index = 0; index < _blocks.Count; index++)
        {
            //if mouse is inside a hitbox, mark as being clicked
            if (_blocks[index].IsCollidingWith(new Hitbox(new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)), new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)))))
            {
                
                _isDragging = true;
                _draggingIndex = index;
            }
        }
    }

    /// <summary>
    /// move the current dragging rect to the mouse and redraw
    /// </summary>
    /// <param name="e"></param>
    private async Task MouseMove(MouseEventArgs e)
    {
        if (!_isDragging) return;

        _blocks[_draggingIndex] = new Hitbox(new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)), new Vector2(await GetRealMouseX(e) + 40, await GetRealMouseY(e) + 20));

        await Redraw();
    }

    /// <summary>
    /// Mouse clicks will handle creations and deletions
    /// </summary>
    /// <param name="e"></param>
    private async Task MouseClick(MouseEventArgs e)
    {
        if (_isDragging) return;

        //if ctrl is pressed, then delete any rectangles under mouse
        if (e.CtrlKey)
        {
            for (var i = 0; i < _blocks.Count; i++)
            {
                if (_blocks[i].IsCollidingWith(new Hitbox(new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)), new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)))))
                {
                    _blocks.RemoveAt(i);

                    await Redraw();
                }
            }
        }

        //if shift clicking, create a new rectangle under mouse
        else if (e.ShiftKey)
        {
            _blocks.Add(new Hitbox(new Vector2(await GetRealMouseX(e), await GetRealMouseY(e)), new Vector2(await GetRealMouseX(e) + 40, await GetRealMouseY(e) + 20)));

            await Redraw();
        }
    }

    private async Task MouseUp(MouseEventArgs e)
    {
        _isDragging = false;

        _draggingIndex = -1;

        await Redraw();

    }

    /// <summary>
    /// clears the canvas and redraw all rectangles
    /// </summary>
    private async Task Redraw()
    {

        await _context.ClearRectAsync(0, 0, _canvasReference.Width, _canvasReference.Height);

        //begin batch
        await _context.BeginBatchAsync();

        for (var index = 0; index < _blocks.Count; index++)
        {
            await _context.FillRectAsync(_blocks[index].TopLeft.X, _blocks[index].TopLeft.Y, 40, 20);
        }

        //end batch
        await _context.EndBatchAsync();

    }

    #endregion

    private async void DownloadMap()
    {
        _map = new GameMap(_blocks.Select(hit => new Block(hit.TopLeft)).ToList());

        //add custom converter
        var opt = new JsonSerializerOptions();
        opt.Converters.Add(new Vector2Converter());

        //download to client by invoking JS
        await JsRuntime.InvokeAsync<object>("FileSaveAs", "level.wamap", JsonSerializer.Serialize(_map,opt));

    }

    private async Task ReadFile()
    {
        //add custom converter
        var opt = new JsonSerializerOptions();
        opt.Converters.Add(new Vector2Converter());

        foreach (var file in await fileReaderService.CreateReference(inputTypeFileElement).EnumerateFilesAsync())
        {
            // Read into buffer and act (uses less memory)
            await using Stream stream = await file.OpenReadAsync();
            _map = await JsonSerializer.DeserializeAsync<GameMap>(stream, opt);

            //refill block array
            _blocks.Clear();
            _blocks = _map.Blocks.ConvertAll(input => input.Hitbox);

        }
    }


}
}
